(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,39584,e=>{"use strict";e.s(["ThemeProvider",()=>r,"useTheme",()=>o]);var t=e.i(81583),n=e.i(46571);let i=(0,n.createContext)(void 0);function r(e){let{children:r,defaultTheme:o="system"}=e,[a,s]=(0,n.useState)(o),[d,c]=(0,n.useState)("light"),[u,h]=(0,n.useState)(!1);return(0,n.useEffect)(()=>{let e=localStorage.getItem("theme"),t=o;e&&["light","dark","system"].includes(e)&&(t=e),window.document.documentElement.classList.contains("dark"),"system"===t?c(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"):c(t),s(t),h(!0)},[o]),(0,n.useEffect)(()=>{if(!u)return;let e=window.document.documentElement;if(e.classList.remove("light","dark"),"system"===a){let t=window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light";e.classList.add(t),c(t)}else e.classList.add(a),c(a);localStorage.setItem("theme",a)},[a,u]),(0,n.useEffect)(()=>{if(!u)return;let e=window.matchMedia("(prefers-color-scheme: dark)"),t=()=>{if("system"===a){let t=e.matches?"dark":"light",n=window.document.documentElement;n.classList.remove("light","dark"),n.classList.add(t),c(t)}};return e.addEventListener("change",t),()=>e.removeEventListener("change",t)},[a,u]),(0,t.jsx)(i.Provider,{value:{theme:a,setTheme:s,resolvedTheme:d},children:r})}function o(){let e=(0,n.useContext)(i);if(void 0===e)throw Error("useTheme must be used within a ThemeProvider");return e}},83436,(e,t,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),Object.defineProperty(n,"BailoutToCSR",{enumerable:!0,get:function(){return r}});let i=e.r(9966);function r(e){let{reason:t,children:n}=e;if("undefined"==typeof window)throw Object.defineProperty(new i.BailoutToCSRError(t),"__NEXT_ERROR_CODE",{value:"E394",enumerable:!1,configurable:!0});return n}},26107,(e,t,n)=>{"use strict";function i(e){return e.split("/").map(e=>encodeURIComponent(e)).join("/")}Object.defineProperty(n,"__esModule",{value:!0}),Object.defineProperty(n,"encodeURIPath",{enumerable:!0,get:function(){return i}})},73686,(e,t,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),Object.defineProperty(n,"PreloadChunks",{enumerable:!0,get:function(){return s}});let i=e.r(81583),r=e.r(49148),o=e.r(40662),a=e.r(26107);function s(e){let{moduleIds:t}=e;if("undefined"!=typeof window)return null;let n=o.workAsyncStorage.getStore();if(void 0===n)return null;let s=[];if(n.reactLoadableManifest&&t){let e=n.reactLoadableManifest;for(let n of t){if(!e[n])continue;let t=e[n].files;s.push(...t)}}return 0===s.length?null:(0,i.jsx)(i.Fragment,{children:s.map(e=>{let t=n.assetPrefix+"/_next/"+(0,a.encodeURIPath)(e);return e.endsWith(".css")?(0,i.jsx)("link",{precedence:"dynamic",href:t,rel:"stylesheet",as:"style"},e):((0,r.preload)(t,{as:"script",fetchPriority:"low"}),null)})})}},83359,(e,t,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),Object.defineProperty(n,"default",{enumerable:!0,get:function(){return c}});let i=e.r(81583),r=e.r(46571),o=e.r(83436),a=e.r(73686);function s(e){return{default:e&&"default"in e?e.default:e}}let d={loader:()=>Promise.resolve(s(()=>null)),loading:null,ssr:!0},c=function(e){let t={...d,...e},n=(0,r.lazy)(()=>t.loader().then(s)),c=t.loading;function u(e){let s=c?(0,i.jsx)(c,{isLoading:!0,pastDelay:!0,error:null}):null,d=!t.ssr||!!t.loading,u=d?r.Suspense:r.Fragment,h=t.ssr?(0,i.jsxs)(i.Fragment,{children:["undefined"==typeof window?(0,i.jsx)(a.PreloadChunks,{moduleIds:t.modules}):null,(0,i.jsx)(n,{...e})]}):(0,i.jsx)(o.BailoutToCSR,{reason:"next/dynamic",children:(0,i.jsx)(n,{...e})});return(0,i.jsx)(u,{...d?{fallback:s}:{},children:h})}return u.displayName="LoadableComponent",u}},5624,(e,t,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),Object.defineProperty(n,"default",{enumerable:!0,get:function(){return r}});let i=e.r(60104)._(e.r(83359));function r(e,t){var n;let r={};"function"==typeof e&&(r.loader=e);let o={...r,...t};return(0,i.default)({...o,modules:null==(n=o.loadableGenerated)?void 0:n.modules})}("function"==typeof n.default||"object"==typeof n.default&&null!==n.default)&&void 0===n.default.__esModule&&(Object.defineProperty(n.default,"__esModule",{value:!0}),Object.assign(n.default,n),t.exports=n.default)},35460,(e,t,n)=>{"use strict";var i,r="object"==typeof Reflect?Reflect:null,o=r&&"function"==typeof r.apply?r.apply:function(e,t,n){return Function.prototype.apply.call(e,t,n)};i=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var a=Number.isNaN||function(e){return e!=e};function s(){s.init.call(this)}t.exports=s,t.exports.once=function(e,t){return new Promise(function(n,i){var r,o,a;function s(n){e.removeListener(t,d),i(n)}function d(){"function"==typeof e.removeListener&&e.removeListener("error",s),n([].slice.call(arguments))}w(e,t,d,{once:!0}),"error"!==t&&(r=e,o=s,a={once:!0},"function"==typeof r.on&&w(r,"error",o,a))})},s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var d=10;function c(e){if("function"!=typeof e)throw TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function u(e){return void 0===e._maxListeners?s.defaultMaxListeners:e._maxListeners}function h(e,t,n,i){if(c(n),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),o=e._events),a=o[t]),void 0===a)a=o[t]=n,++e._eventsCount;else if("function"==typeof a?a=o[t]=i?[n,a]:[a,n]:i?a.unshift(n):a.push(n),(r=u(e))>0&&a.length>r&&!a.warned){a.warned=!0;var r,o,a,s=Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");s.name="MaxListenersExceededWarning",s.emitter=e,s.type=t,s.count=a.length,console&&console.warn&&console.warn(s)}return e}function l(){if(!this.fired)return(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0==arguments.length)?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function p(e,t,n){var i={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},r=l.bind(i);return r.listener=n,i.wrapFn=r,r}function f(e,t,n){var i=e._events;if(void 0===i)return[];var r=i[t];return void 0===r?[]:"function"==typeof r?n?[r.listener||r]:[r]:n?function(e){for(var t=Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(r):y(r,r.length)}function g(e){var t=this._events;if(void 0!==t){var n=t[e];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function y(e,t){for(var n=Array(t),i=0;i<t;++i)n[i]=e[i];return n}function w(e,t,n,i){if("function"==typeof e.on)i.once?e.once(t,n):e.on(t,n);else if("function"==typeof e.addEventListener)e.addEventListener(t,function r(o){i.once&&e.removeEventListener(t,r),n(o)});else throw TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e)}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return d},set:function(e){if("number"!=typeof e||e<0||a(e))throw RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");d=e}}),s.init=function(){(void 0===this._events||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||a(e))throw RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},s.prototype.getMaxListeners=function(){return u(this)},s.prototype.emit=function(e){for(var t=[],n=1;n<arguments.length;n++)t.push(arguments[n]);var i="error"===e,r=this._events;if(void 0!==r)i=i&&void 0===r.error;else if(!i)return!1;if(i){if(t.length>0&&(a=t[0]),a instanceof Error)throw a;var a,s=Error("Unhandled error."+(a?" ("+a.message+")":""));throw s.context=a,s}var d=r[e];if(void 0===d)return!1;if("function"==typeof d)o(d,this,t);else for(var c=d.length,u=y(d,c),n=0;n<c;++n)o(u[n],this,t);return!0},s.prototype.addListener=function(e,t){return h(this,e,t,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(e,t){return h(this,e,t,!0)},s.prototype.once=function(e,t){return c(t),this.on(e,p(this,e,t)),this},s.prototype.prependOnceListener=function(e,t){return c(t),this.prependListener(e,p(this,e,t)),this},s.prototype.removeListener=function(e,t){var n,i,r,o,a;if(c(t),void 0===(i=this._events)||void 0===(n=i[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete i[e],i.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(r=-1,o=n.length-1;o>=0;o--)if(n[o]===t||n[o].listener===t){a=n[o].listener,r=o;break}if(r<0)return this;0===r?n.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(n,r),1===n.length&&(i[e]=n[0]),void 0!==i.removeListener&&this.emit("removeListener",e,a||t)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(e){var t,n,i;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0==arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[e]),this;if(0==arguments.length){var r,o=Object.keys(n);for(i=0;i<o.length;++i)"removeListener"!==(r=o[i])&&this.removeAllListeners(r);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(void 0!==t)for(i=t.length-1;i>=0;i--)this.removeListener(e,t[i]);return this},s.prototype.listeners=function(e){return f(this,e,!0)},s.prototype.rawListeners=function(e){return f(this,e,!1)},s.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):g.call(e,t)},s.prototype.listenerCount=g,s.prototype.eventNames=function(){return this._eventsCount>0?i(this._events):[]}},19134,86282,e=>{"use strict";e.s(["default",()=>J],19134);var t=e.i(35460);let n=function(){let e=arguments[0];for(let t=1,n=arguments.length;t<n;t++)if(arguments[t])for(let n in arguments[t])e[n]=arguments[t][n];return e};function i(e,t,n,i){let r=e._nodes.get(t),o=null;return r?o="mixed"===i?r.out&&r.out[n]||r.undirected&&r.undirected[n]:"directed"===i?r.out&&r.out[n]:r.undirected&&r.undirected[n]:o}function r(e){return"object"==typeof e&&null!==e}function o(e){let t;for(t in e)return!1;return!0}function a(e,t,n){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:n})}function s(e,t,n){let i={enumerable:!0,configurable:!0};"function"==typeof n?i.get=n:(i.value=n,i.writable=!1),Object.defineProperty(e,t,i)}function d(e){return!!r(e)&&(!e.attributes||!!Array.isArray(e.attributes))}function c(){let e=arguments,t=null,n=-1;return{[Symbol.iterator](){return this},next(){let i=null;for(;;){if(null===t){if(++n>=e.length)return{done:!0};t=e[n][Symbol.iterator]()}if((i=t.next()).done){t=null;continue}break}return i}}}function u(){return{[Symbol.iterator](){return this},next:()=>({done:!0})}}"function"==typeof Object.assign&&(n=Object.assign);class h extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class l extends h{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,l.prototype.constructor)}}class p extends h{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,p.prototype.constructor)}}class f extends h{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,f.prototype.constructor)}}function g(e,t){this.key=e,this.attributes=t,this.clear()}function y(e,t){this.key=e,this.attributes=t,this.clear()}function w(e,t){this.key=e,this.attributes=t,this.clear()}function m(e,t,n,i,r){this.key=t,this.attributes=r,this.undirected=e,this.source=n,this.target=i}function b(e,t,n,i,r,o,a){let s,d,c,u;if(i=""+i,0===n){if(!(s=e._nodes.get(i)))throw new p("Graph.".concat(t,': could not find the "').concat(i,'" node in the graph.'));c=r,u=o}else if(3===n){if(r=""+r,!(d=e._edges.get(r)))throw new p("Graph.".concat(t,': could not find the "').concat(r,'" edge in the graph.'));let n=d.source.key,h=d.target.key;if(i===n)s=d.target;else if(i===h)s=d.source;else throw new p("Graph.".concat(t,': the "').concat(i,'" node is not attached to the "').concat(r,'" edge (').concat(n,", ").concat(h,")."));c=o,u=a}else{if(!(d=e._edges.get(i)))throw new p("Graph.".concat(t,': could not find the "').concat(i,'" edge in the graph.'));s=1===n?d.source:d.target,c=r,u=o}return[s,c,u]}g.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},y.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},w.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},m.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");let n=this.source.key,i=this.target.key;this.source[e][i]=this,this.undirected&&n===i||(this.target[t][n]=this)},m.prototype.attachMulti=function(){let e="out",t="in",n=this.source.key,i=this.target.key;this.undirected&&(e=t="undirected");let r=this.source[e],o=r[i];if(void 0===o){r[i]=this,this.undirected&&n===i||(this.target[t][n]=this);return}o.previous=this,this.next=o,r[i]=this,this.target[t][n]=this},m.prototype.detach=function(){let e=this.source.key,t=this.target.key,n="out",i="in";this.undirected&&(n=i="undirected"),delete this.source[n][t],delete this.target[i][e]},m.prototype.detachMulti=function(){let e=this.source.key,t=this.target.key,n="out",i="in";this.undirected&&(n=i="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[n][t],delete this.target[i][e]):(this.next.previous=void 0,this.source[n][t]=this.next,this.target[i][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};let v=[{name:e=>"get".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,i,r){let[o,a]=b(this,t,n,e,i,r);return o.attributes[a]}}},{name:e=>"get".concat(e,"Attributes"),attacher:function(e,t,n){e.prototype[t]=function(e,i){let[r]=b(this,t,n,e,i);return r.attributes}}},{name:e=>"has".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,i,r){let[o,a]=b(this,t,n,e,i,r);return o.attributes.hasOwnProperty(a)}}},{name:e=>"set".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,i,r,o){let[a,s,d]=b(this,t,n,e,i,r,o);return a.attributes[s]=d,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:s}),this}}},{name:e=>"update".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,i,r,o){let[a,s,d]=b(this,t,n,e,i,r,o);if("function"!=typeof d)throw new l("Graph.".concat(t,": updater should be a function."));let c=a.attributes,u=d(c[s]);return c[s]=u,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:s}),this}}},{name:e=>"remove".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,i,r){let[o,a]=b(this,t,n,e,i,r);return delete o.attributes[a],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:a}),this}}},{name:e=>"replace".concat(e,"Attributes"),attacher:function(e,t,n){e.prototype[t]=function(e,i,o){let[a,s]=b(this,t,n,e,i,o);if(!r(s))throw new l("Graph.".concat(t,": provided attributes are not a plain object."));return a.attributes=s,this.emit("nodeAttributesUpdated",{key:a.key,type:"replace",attributes:a.attributes}),this}}},{name:e=>"merge".concat(e,"Attributes"),attacher:function(e,t,i){e.prototype[t]=function(e,o,a){let[s,d]=b(this,t,i,e,o,a);if(!r(d))throw new l("Graph.".concat(t,": provided attributes are not a plain object."));return n(s.attributes,d),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:d}),this}}},{name:e=>"update".concat(e,"Attributes"),attacher:function(e,t,n){e.prototype[t]=function(e,i,r){let[o,a]=b(this,t,n,e,i,r);if("function"!=typeof a)throw new l("Graph.".concat(t,": provided updater is not a function."));return o.attributes=a(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}],k=[{name:e=>"get".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let a=""+e,s=""+r;if(r=arguments[2],!(o=i(this,a,s,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(o=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}return o.attributes[r]}}},{name:e=>"get".concat(e,"Attributes"),attacher:function(e,t,n){e.prototype[t]=function(e){let r;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let o=""+e,a=""+arguments[1];if(!(r=i(this,o,a,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(o,'" - "').concat(a,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(r=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}return r.attributes}}},{name:e=>"has".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let a=""+e,s=""+r;if(r=arguments[2],!(o=i(this,a,s,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(o=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}return o.attributes.hasOwnProperty(r)}}},{name:e=>"set".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,r,o){let a;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let s=""+e,d=""+r;if(r=arguments[2],o=arguments[3],!(a=i(this,s,d,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(s,'" - "').concat(d,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(a=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}return a.attributes[r]=o,this.emit("edgeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:r}),this}}},{name:e=>"update".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,r,o){let a;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let s=""+e,d=""+r;if(r=arguments[2],o=arguments[3],!(a=i(this,s,d,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(s,'" - "').concat(d,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(a=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}if("function"!=typeof o)throw new l("Graph.".concat(t,": updater should be a function."));return a.attributes[r]=o(a.attributes[r]),this.emit("edgeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:r}),this}}},{name:e=>"remove".concat(e,"Attribute"),attacher:function(e,t,n){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let a=""+e,s=""+r;if(r=arguments[2],!(o=i(this,a,s,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(o=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}return delete o.attributes[r],this.emit("edgeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:r}),this}}},{name:e=>"replace".concat(e,"Attributes"),attacher:function(e,t,n){e.prototype[t]=function(e,o){let a;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let r=""+e,s=""+o;if(o=arguments[2],!(a=i(this,r,s,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(r,'" - "').concat(s,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(a=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}if(!r(o))throw new l("Graph.".concat(t,": provided attributes are not a plain object."));return a.attributes=o,this.emit("edgeAttributesUpdated",{key:a.key,type:"replace",attributes:a.attributes}),this}}},{name:e=>"merge".concat(e,"Attributes"),attacher:function(e,t,o){e.prototype[t]=function(e,a){let s;if("mixed"!==this.type&&"mixed"!==o&&o!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let n=""+e,r=""+a;if(a=arguments[2],!(s=i(this,n,r,o)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(n,'" - "').concat(r,'").'))}else{if("mixed"!==o)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(s=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}if(!r(a))throw new l("Graph.".concat(t,": provided attributes are not a plain object."));return n(s.attributes,a),this.emit("edgeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:a}),this}}},{name:e=>"update".concat(e,"Attributes"),attacher:function(e,t,n){e.prototype[t]=function(e,r){let o;if("mixed"!==this.type&&"mixed"!==n&&n!==this.type)throw new f("Graph.".concat(t,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new f("Graph.".concat(t,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));let a=""+e,s=""+r;if(r=arguments[2],!(o=i(this,a,s,n)))throw new p("Graph.".concat(t,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==n)throw new f("Graph.".concat(t,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(e=""+e,!(o=this._edges.get(e)))throw new p("Graph.".concat(t,': could not find the "').concat(e,'" edge in the graph.'))}if("function"!=typeof r)throw new l("Graph.".concat(t,": provided updater is not a function."));return o.attributes=r(o.attributes),this.emit("edgeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}],_=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function G(e,t,n,i){let r=!1;for(let o in t){if(o===i)continue;let a=t[o];if(r=n(a.key,a.attributes,a.source.key,a.target.key,a.source.attributes,a.target.attributes,a.undirected),e&&r)return a.key}}function x(e,t,n,i){let r,o,a,s=!1;for(let d in t)if(d!==i){r=t[d];do{if(o=r.source,a=r.target,s=n(r.key,r.attributes,o.key,a.key,o.attributes,a.attributes,r.undirected),e&&s)return r.key;r=r.next}while(void 0!==r)}}function E(e,t){let n,i=Object.keys(e),r=i.length,o=0;return{[Symbol.iterator](){return this},next(){do if(n)n=n.next;else{if(o>=r)return{done:!0};let a=i[o++];if(a===t){n=void 0;continue}n=e[a]}while(!n)return{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}}}}function L(e,t,n,i){let r=t[n];if(!r)return;let o=r.source,a=r.target;if(i(r.key,r.attributes,o.key,a.key,o.attributes,a.attributes,r.undirected)&&e)return r.key}function A(e,t,n,i){let r=t[n];if(!r)return;let o=!1;do{if(o=i(r.key,r.attributes,r.source.key,r.target.key,r.source.attributes,r.target.attributes,r.undirected),e&&o)return r.key;r=r.next}while(void 0!==r)}function S(e,t){let n=e[t];if(void 0!==n.next)return{[Symbol.iterator](){return this},next(){if(!n)return{done:!0};let e={edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected};return n=n.next,{done:!1,value:e}}};let i=!1;return{[Symbol.iterator](){return this},next:()=>!0===i?{done:!0}:(i=!0,{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}})}}function D(e,t,n,i){let r,o;if(0===t.size)return;let a="mixed"!==n&&n!==t.type,s="undirected"===n,d=!1,c=t._edges.values();for(;!0!==(r=c.next()).done;){if(o=r.value,a&&o.undirected!==s)continue;let{key:t,attributes:n,source:c,target:u}=o;if(d=i(t,n,c.key,u.key,c.attributes,u.attributes,o.undirected),e&&d)return t}}function U(e,t,n,i,r,o){let a,s=t?x:G;if("undirected"!==n&&("out"!==i&&(a=s(e,r.in,o),e&&a)||"in"!==i&&(a=s(e,r.out,o,i?void 0:r.key),e&&a)))return a;if("directed"!==n&&(a=s(e,r.undirected,o),e&&a))return a}function j(e,t,n,i,r,o,a){let s,d=n?A:L;if("undirected"!==t&&(void 0!==r.in&&"out"!==i&&(s=d(e,r.in,o,a),e&&s)||void 0!==r.out&&"in"!==i&&(i||r.key!==o)&&(s=d(e,r.out,o,a),e&&s)))return s;if("directed"!==t&&void 0!==r.undirected&&(s=d(e,r.undirected,o,a),e&&s))return s}let N=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function C(){this.A=null,this.B=null}function O(e,t,n,i,r){for(let o in i){let a=i[o],s=a.source,d=a.target,c=s===n?d:s;if(t&&t.has(c.key))continue;let u=r(c.key,c.attributes);if(e&&u)return c.key}}function M(e,t,n,i,r){let o;if("mixed"!==t){if("undirected"===t)return O(e,null,i,i.undirected,r);if("string"==typeof n)return O(e,null,i,i[n],r)}let a=new C;if("undirected"!==t){if("out"!==n){if(o=O(e,null,i,i.in,r),e&&o)return o;a.wrap(i.in)}if("in"!==n){if(o=O(e,a,i,i.out,r),e&&o)return o;a.wrap(i.out)}}if("directed"!==t&&(o=O(e,a,i,i.undirected,r),e&&o))return o}function P(e,t,n){let i=Object.keys(n),r=i.length,o=0;return{[Symbol.iterator](){return this},next(){let a=null;do{if(o>=r)return e&&e.wrap(n),{done:!0};let s=n[i[o++]],d=s.source,c=s.target;if(a=d===t?c:d,e&&e.has(a.key)){a=null;continue}}while(null===a)return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}}}}function z(e,t,n,i,r){let o,a,s,d,c,u,h,l=i._nodes.values(),p=i.type;for(;!0!==(o=l.next()).done;){let i=!1;if(a=o.value,"undirected"!==p)for(s in d=a.out){c=d[s];do{if(u=c.target,i=!0,h=r(a.key,u.key,a.attributes,u.attributes,c.key,c.attributes,c.undirected),e&&h)return c;c=c.next}while(c)}if("directed"!==p){for(s in d=a.undirected)if(!t||!(a.key>s)){c=d[s];do{if((u=c.target).key!==s&&(u=c.source),i=!0,h=r(a.key,u.key,a.attributes,u.attributes,c.key,c.attributes,c.undirected),e&&h)return c;c=c.next}while(c)}}if(n&&!i&&(h=r(a.key,null,a.attributes,null,null,null,null),e&&h))return null}}C.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},C.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};let W=function(){let e=255&Math.floor(256*Math.random());return()=>e++}(),T=new Set(["directed","undirected","mixed"]),K=new Set(["domain","_events","_eventsCount","_maxListeners"]),R={allowSelfLoops:!0,multi:!1,type:"mixed"};function I(e,t,n){let i=new e.NodeDataClass(t,n);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:n}),i}function B(e,t,n,i,o,a,s,d){if(!i&&"undirected"===e.type)throw new f("Graph.".concat(t,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(i&&"directed"===e.type)throw new f("Graph.".concat(t,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(d&&!r(d))throw new l("Graph.".concat(t,': invalid attributes. Expecting an object but got "').concat(d,'"'));if(a=""+a,s=""+s,d=d||{},!e.allowSelfLoops&&a===s)throw new f("Graph.".concat(t,': source & target are the same ("').concat(a,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));let c=e._nodes.get(a),u=e._nodes.get(s);if(!c)throw new p("Graph.".concat(t,': source node "').concat(a,'" not found.'));if(!u)throw new p("Graph.".concat(t,': target node "').concat(s,'" not found.'));let h={key:null,undirected:i,source:a,target:s,attributes:d};if(n)o=e._edgeKeyGenerator();else if(o=""+o,e._edges.has(o))throw new f("Graph.".concat(t,': the "').concat(o,'" edge already exists in the graph.'));if(!e.multi&&(i?void 0!==c.undirected[s]:void 0!==c.out[s]))throw new f("Graph.".concat(t,': an edge linking "').concat(a,'" to "').concat(s,"\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option."));let g=new m(i,o,c,u,d);e._edges.set(o,g);let y=a===s;return i?(c.undirectedDegree++,u.undirectedDegree++,y&&(c.undirectedLoops++,e._undirectedSelfLoopCount++)):(c.outDegree++,u.inDegree++,y&&(c.directedLoops++,e._directedSelfLoopCount++)),e.multi?g.attachMulti():g.attach(),i?e._undirectedSize++:e._directedSize++,h.key=o,e.emit("edgeAdded",h),o}function F(e,t,i,o,a,s,d,c,u){let h,p,g;if(!o&&"undirected"===e.type)throw new f("Graph.".concat(t,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(o&&"directed"===e.type)throw new f("Graph.".concat(t,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(c){if(u){if("function"!=typeof c)throw new l("Graph.".concat(t,': invalid updater function. Expecting a function but got "').concat(c,'"'))}else if(!r(c))throw new l("Graph.".concat(t,': invalid attributes. Expecting an object but got "').concat(c,'"'))}if(s=""+s,d=""+d,u&&(h=c,c=void 0),!e.allowSelfLoops&&s===d)throw new f("Graph.".concat(t,': source & target are the same ("').concat(s,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));let y=e._nodes.get(s),w=e._nodes.get(d);if(!i&&(p=e._edges.get(a))){if((p.source.key!==s||p.target.key!==d)&&(!o||p.source.key!==d||p.target.key!==s))throw new f("Graph.".concat(t,': inconsistency detected when attempting to merge the "').concat(a,'" edge with "').concat(s,'" source & "').concat(d,'" target vs. ("').concat(p.source.key,'", "').concat(p.target.key,'").'));g=p}if(g||e.multi||!y||(g=o?y.undirected[d]:y.out[d]),g){let t=[g.key,!1,!1,!1];if(u?!h:!c)return t;if(u){let t=g.attributes;g.attributes=h(t),e.emit("edgeAttributesUpdated",{type:"replace",key:g.key,attributes:g.attributes})}else n(g.attributes,c),e.emit("edgeAttributesUpdated",{type:"merge",key:g.key,attributes:g.attributes,data:c});return t}c=c||{},u&&h&&(c=h(c));let b={key:null,undirected:o,source:s,target:d,attributes:c};if(i)a=e._edgeKeyGenerator();else if(a=""+a,e._edges.has(a))throw new f("Graph.".concat(t,': the "').concat(a,'" edge already exists in the graph.'));let v=!1,k=!1;y||(y=I(e,s,{}),v=!0,s===d&&(w=y,k=!0)),w||(w=I(e,d,{}),k=!0),p=new m(o,a,y,w,c),e._edges.set(a,p);let _=s===d;return o?(y.undirectedDegree++,w.undirectedDegree++,_&&(y.undirectedLoops++,e._undirectedSelfLoopCount++)):(y.outDegree++,w.inDegree++,_&&(y.directedLoops++,e._directedSelfLoopCount++)),e.multi?p.attachMulti():p.attach(),o?e._undirectedSize++:e._directedSize++,b.key=a,e.emit("edgeAdded",b),[a,!0,v,k]}function Y(e,t){e._edges.delete(t.key);let{source:n,target:i,attributes:r}=t,o=t.undirected,a=n===i;o?(n.undirectedDegree--,i.undirectedDegree--,a&&(n.undirectedLoops--,e._undirectedSelfLoopCount--)):(n.outDegree--,i.inDegree--,a&&(n.directedLoops--,e._directedSelfLoopCount--)),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:r,source:n.key,target:i.key,undirected:o})}class J extends t.EventEmitter{_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1==arguments.length){let t=""+e,n=this._edges.get(t);return!!n&&!n.undirected}if(2==arguments.length){e=""+e,t=""+t;let n=this._nodes.get(e);return!!n&&n.out.hasOwnProperty(t)}throw new l("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1==arguments.length){let t=""+e,n=this._edges.get(t);return!!n&&n.undirected}if(2==arguments.length){e=""+e,t=""+t;let n=this._nodes.get(e);return!!n&&n.undirected.hasOwnProperty(t)}throw new l("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))}hasEdge(e,t){if(1==arguments.length){let t=""+e;return this._edges.has(t)}if(2==arguments.length){e=""+e,t=""+t;let n=this._nodes.get(e);return!!n&&(void 0!==n.out&&n.out.hasOwnProperty(t)||void 0!==n.undirected&&n.undirected.hasOwnProperty(t))}throw new l("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))}directedEdge(e,t){if("undirected"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new f("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");let n=this._nodes.get(e);if(!n)throw new p('Graph.directedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new p('Graph.directedEdge: could not find the "'.concat(t,'" target node in the graph.'));let i=n.out&&n.out[t]||void 0;if(i)return i.key}undirectedEdge(e,t){if("directed"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new f("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");let n=this._nodes.get(e);if(!n)throw new p('Graph.undirectedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new p('Graph.undirectedEdge: could not find the "'.concat(t,'" target node in the graph.'));let i=n.undirected&&n.undirected[t]||void 0;if(i)return i.key}edge(e,t){if(this.multi)throw new f("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.edge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new p('Graph.edge: could not find the "'.concat(t,'" target node in the graph.'));let i=n.out&&n.out[t]||n.undirected&&n.undirected[t]||void 0;if(i)return i.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.areDirectedNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&(t in n.in||t in n.out)}areOutNeighbors(e,t){e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.areOutNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in n.out}areInNeighbors(e,t){e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.areInNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in n.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.areUndirectedNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"directed"!==this.type&&t in n.undirected}areNeighbors(e,t){e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.areNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&(t in n.in||t in n.out)||"directed"!==this.type&&t in n.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.areInboundNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in n.in||"directed"!==this.type&&t in n.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;let n=this._nodes.get(e);if(!n)throw new p('Graph.areOutboundNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in n.out||"directed"!==this.type&&t in n.undirected}inDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.inDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree}outDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.outDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.outDegree}directedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.directedDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.undirectedDegree: could not find the "'.concat(e,'" node in the graph.'));return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.inboundDegree: could not find the "'.concat(e,'" node in the graph.'));let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.inDegree),n}outboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.outboundDegree: could not find the "'.concat(e,'" node in the graph.'));let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.outDegree),n}degree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.degree: could not find the "'.concat(e,'" node in the graph.'));let n=0;return"directed"!==this.type&&(n+=t.undirectedDegree),"undirected"!==this.type&&(n+=t.inDegree+t.outDegree),n}inDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree+t.outDegree-2*t.directedLoops}undirectedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));return"directed"===this.type?0:t.undirectedDegree-2*t.undirectedLoops}inboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));let n=0,i=0;return"directed"!==this.type&&(n+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.inDegree,i+=t.directedLoops),n-i}outboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));let n=0,i=0;return"directed"!==this.type&&(n+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.outDegree,i+=t.directedLoops),n-i}degreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new p('Graph.degreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));let n=0,i=0;return"directed"!==this.type&&(n+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(n+=t.inDegree+t.outDegree,i+=2*t.directedLoops),n-i}source(e){e=""+e;let t=this._edges.get(e);if(!t)throw new p('Graph.source: could not find the "'.concat(e,'" edge in the graph.'));return t.source.key}target(e){e=""+e;let t=this._edges.get(e);if(!t)throw new p('Graph.target: could not find the "'.concat(e,'" edge in the graph.'));return t.target.key}extremities(e){e=""+e;let t=this._edges.get(e);if(!t)throw new p('Graph.extremities: could not find the "'.concat(e,'" edge in the graph.'));return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;let n=this._edges.get(t);if(!n)throw new p('Graph.opposite: could not find the "'.concat(t,'" edge in the graph.'));let i=n.source.key,r=n.target.key;if(e===i)return r;if(e===r)return i;throw new p('Graph.opposite: the "'.concat(e,'" node is not attached to the "').concat(t,'" edge (').concat(i,", ").concat(r,")."))}hasExtremity(e,t){e=""+e,t=""+t;let n=this._edges.get(e);if(!n)throw new p('Graph.hasExtremity: could not find the "'.concat(e,'" edge in the graph.'));return n.source.key===t||n.target.key===t}isUndirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new p('Graph.isUndirected: could not find the "'.concat(e,'" edge in the graph.'));return t.undirected}isDirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new p('Graph.isDirected: could not find the "'.concat(e,'" edge in the graph.'));return!t.undirected}isSelfLoop(e){e=""+e;let t=this._edges.get(e);if(!t)throw new p('Graph.isSelfLoop: could not find the "'.concat(e,'" edge in the graph.'));return t.source===t.target}addNode(e,t){return function(e,t,n){if(n&&!r(n))throw new l('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(n,'"'));if(t=""+t,n=n||{},e._nodes.has(t))throw new f('Graph.addNode: the "'.concat(t,'" node already exist in the graph.'));let i=new e.NodeDataClass(t,n);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:n}),i}(this,e,t).key}mergeNode(e,t){if(t&&!r(t))throw new l('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(t,'"'));e=""+e,t=t||{};let i=this._nodes.get(e);return i?(t&&(n(i.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:i.attributes,data:t})),[e,!1]):(i=new this.NodeDataClass(e,t),this._nodes.set(e,i),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new l('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(t,'"'));e=""+e;let n=this._nodes.get(e);if(n){if(t){let i=n.attributes;n.attributes=t(i),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:n.attributes})}return[e,!1]}let i=t?t({}):{};return n=new this.NodeDataClass(e,i),this._nodes.set(e,n),this.emit("nodeAdded",{key:e,attributes:i}),[e,!0]}dropNode(e){let t;e=""+e;let n=this._nodes.get(e);if(!n)throw new p('Graph.dropNode: could not find the "'.concat(e,'" node in the graph.'));if("undirected"!==this.type){for(let e in n.out){t=n.out[e];do Y(this,t),t=t.next;while(t)}for(let e in n.in){t=n.in[e];do Y(this,t),t=t.next;while(t)}}if("directed"!==this.type)for(let e in n.undirected){t=n.undirected[e];do Y(this,t),t=t.next;while(t)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:n.attributes})}dropEdge(e){let t;if(arguments.length>1){let e=""+arguments[0],n=""+arguments[1];if(!(t=i(this,e,n,this.type)))throw new p('Graph.dropEdge: could not find the "'.concat(e,'" -> "').concat(n,'" edge in the graph.'))}else if(e=""+e,!(t=this._edges.get(e)))throw new p('Graph.dropEdge: could not find the "'.concat(e,'" edge in the graph.'));return Y(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new f("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new f("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let n=i(this,e=""+e,t=""+t,"directed");if(!n)throw new p('Graph.dropDirectedEdge: could not find a "'.concat(e,'" -> "').concat(t,'" edge in the graph.'));return Y(this,n),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new f("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new f("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let n=i(this,e,t,"undirected");if(!n)throw new p('Graph.dropUndirectedEdge: could not find a "'.concat(e,'" -> "').concat(t,'" edge in the graph.'));return Y(this,n),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){let e,t=this._nodes.values();for(;!0!==(e=t.next()).done;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new l("Graph.updateAttribute: updater should be a function.");let n=this._attributes[e];return this._attributes[e]=t(n),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!r(e))throw new l("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!r(e))throw new l("Graph.mergeAttributes: provided attributes are not a plain object.");return n(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new l("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){let n,i;if("function"!=typeof e)throw new l("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!d(t))throw new l("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let r=this._nodes.values();for(;!0!==(n=r.next()).done;)(i=n.value).attributes=e(i.key,i.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){let n,i,r,o;if("function"!=typeof e)throw new l("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!d(t))throw new l("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let a=this._edges.values();for(;!0!==(n=a.next()).done;)r=(i=n.value).source,o=i.target,i.attributes=e(i.key,i.attributes,r.key,o.key,r.attributes,o.attributes,i.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new l("Graph.forEachAdjacencyEntry: expecting a callback.");z(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new l("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");z(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new l("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");z(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new l("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");z(!1,!0,!0,this,e)}nodes(){return Array.from(this._nodes.keys())}forEachNode(e){let t,n;if("function"!=typeof e)throw new l("Graph.forEachNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)e((n=t.value).key,n.attributes)}findNode(e){let t,n;if("function"!=typeof e)throw new l("Graph.findNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(e((n=t.value).key,n.attributes))return n.key}mapNodes(e){let t,n;if("function"!=typeof e)throw new l("Graph.mapNode: expecting a callback.");let i=this._nodes.values(),r=Array(this.order),o=0;for(;!0!==(t=i.next()).done;)n=t.value,r[o++]=e(n.key,n.attributes);return r}someNode(e){let t,n;if("function"!=typeof e)throw new l("Graph.someNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(e((n=t.value).key,n.attributes))return!0;return!1}everyNode(e){let t,n;if("function"!=typeof e)throw new l("Graph.everyNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(!e((n=t.value).key,n.attributes))return!1;return!0}filterNodes(e){let t,n;if("function"!=typeof e)throw new l("Graph.filterNodes: expecting a callback.");let i=this._nodes.values(),r=[];for(;!0!==(t=i.next()).done;)e((n=t.value).key,n.attributes)&&r.push(n.key);return r}reduceNodes(e,t){let n,i;if("function"!=typeof e)throw new l("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new l("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let r=t,o=this._nodes.values();for(;!0!==(n=o.next()).done;)r=e(r,(i=n.value).key,i.attributes);return r}nodeEntries(){let e=this._nodes.values();return{[Symbol.iterator](){return this},next(){let t=e.next();if(t.done)return t;let n=t.value;return{value:{node:n.key,attributes:n.attributes},done:!1}}}}export(){let e=Array(this._nodes.size),t=0;this._nodes.forEach((i,r)=>{e[t++]=function(e,t){let i={key:e};return o(t.attributes)||(i.attributes=n({},t.attributes)),i}(r,i)});let i=Array(this._edges.size);return t=0,this._edges.forEach((e,r)=>{i[t++]=function(e,t,i){let r={key:t,source:i.source.key,target:i.target.key};return o(i.attributes)||(r.attributes=n({},i.attributes)),"mixed"===e&&i.undirected&&(r.undirected=!0),r}(this.type,r,e)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:i}}import(e){let t,n,i,o,a,s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(e instanceof J)return e.forEachNode((e,t)=>{s?this.mergeNode(e,t):this.addNode(e,t)}),e.forEachEdge((e,t,n,i,r,o,a)=>{s?a?this.mergeUndirectedEdgeWithKey(e,n,i,t):this.mergeDirectedEdgeWithKey(e,n,i,t):a?this.addUndirectedEdgeWithKey(e,n,i,t):this.addDirectedEdgeWithKey(e,n,i,t)}),this;if(!r(e))throw new l("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!r(e.attributes))throw new l("Graph.import: invalid attributes. Expecting a plain object.");s?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}if(e.nodes){if(!Array.isArray(i=e.nodes))throw new l("Graph.import: invalid nodes. Expecting an array.");for(t=0,n=i.length;t<n;t++){var d=o=i[t];if(!r(d))throw new l('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in d))throw new l("Graph.import: serialized node is missing its key.");if("attributes"in d&&(!r(d.attributes)||null===d.attributes))throw new l("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");let{key:e,attributes:n}=o;s?this.mergeNode(e,n):this.addNode(e,n)}}if(e.edges){let o=!1;if("undirected"===this.type&&(o=!0),!Array.isArray(i=e.edges))throw new l("Graph.import: invalid edges. Expecting an array.");for(t=0,n=i.length;t<n;t++){var c=a=i[t];if(!r(c))throw new l('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in c))throw new l("Graph.import: serialized edge is missing its source.");if(!("target"in c))throw new l("Graph.import: serialized edge is missing its target.");if("attributes"in c&&(!r(c.attributes)||null===c.attributes))throw new l("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in c&&"boolean"!=typeof c.undirected)throw new l("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.");let{source:e,target:n,attributes:d,undirected:u=o}=a;"key"in a?(s?u?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:u?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,a.key,e,n,d):(s?u?this.mergeUndirectedEdge:this.mergeDirectedEdge:u?this.addUndirectedEdge:this.addDirectedEdge).call(this,e,n,d)}}return this}nullCopy(e){let t=new J(n({},this._options,e));return t.replaceAttributes(n({},this.getAttributes())),t}emptyCopy(e){let t=this.nullCopy(e);return this._nodes.forEach((e,i)=>{let r=n({},e.attributes);e=new t.NodeDataClass(i,r),t._nodes.set(i,e)}),t}copy(e){let t,i;if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new f('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(e.type,'" because this would mean losing information about the current graph.'));if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new f("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new f("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");let r=this.emptyCopy(e),o=this._edges.values();for(;!0!==(t=o.next()).done;)B(r,"copy",!1,(i=t.value).undirected,i.key,i.source.key,i.target.key,n({},i.attributes));return r}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){let e={};this._nodes.forEach((t,n)=>{e[n]=t.attributes});let t={},n={};this._edges.forEach((e,i)=>{let r,o=e.undirected?"--":"->",a="",s=e.source.key,d=e.target.key;e.undirected&&s>d&&(r=s,s=d,d=r);let c="(".concat(s,")").concat(o,"(").concat(d,")");i.startsWith("geid_")?this.multi&&(void 0===n[c]?n[c]=0:n[c]++,a+="".concat(n[c],". ")):a+="[".concat(i,"]: "),t[a+=c]=e.attributes});let i={};for(let e in this)this.hasOwnProperty(e)&&!K.has(e)&&"function"!=typeof this[e]&&"symbol"!=typeof e&&(i[e]=this[e]);return i.attributes=this._attributes,i.nodes=e,i.edges=t,a(i,"constructor",this.constructor),i}constructor(e){if(super(),"boolean"!=typeof(e=n({},R,e)).multi)throw new l("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(e.multi,'".'));if(!T.has(e.type))throw new l('Graph.constructor: invalid \'type\' option. Should be one of "mixed", "directed" or "undirected" but got "'.concat(e.type,'".'));if("boolean"!=typeof e.allowSelfLoops)throw new l("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(e.allowSelfLoops,'".'));a(this,"NodeDataClass","mixed"===e.type?g:"directed"===e.type?y:w);let t="geid_"+W()+"_",i=0,r=()=>{let e;do e=t+i++;while(this._edges.has(e))return e};a(this,"_attributes",{}),a(this,"_nodes",new Map),a(this,"_edges",new Map),a(this,"_directedSize",0),a(this,"_undirectedSize",0),a(this,"_directedSelfLoopCount",0),a(this,"_undirectedSelfLoopCount",0),a(this,"_edgeKeyGenerator",r),a(this,"_options",e),K.forEach(e=>a(this,e,this[e])),s(this,"order",()=>this._nodes.size),s(this,"size",()=>this._edges.size),s(this,"directedSize",()=>this._directedSize),s(this,"undirectedSize",()=>this._undirectedSize),s(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),s(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),s(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),s(this,"multi",this._options.multi),s(this,"type",this._options.type),s(this,"allowSelfLoops",this._options.allowSelfLoops),s(this,"implementation",()=>"graphology")}}"undefined"!=typeof Symbol&&(J.prototype[Symbol.for("nodejs.util.inspect.custom")]=J.prototype.inspect),[{name:e=>"".concat(e,"Edge"),generateKey:!0},{name:e=>"".concat(e,"DirectedEdge"),generateKey:!0,type:"directed"},{name:e=>"".concat(e,"UndirectedEdge"),generateKey:!0,type:"undirected"},{name:e=>"".concat(e,"EdgeWithKey")},{name:e=>"".concat(e,"DirectedEdgeWithKey"),type:"directed"},{name:e=>"".concat(e,"UndirectedEdgeWithKey"),type:"undirected"}].forEach(e=>{["add","merge","update"].forEach(t=>{let n=e.name(t),i="add"===t?B:F;e.generateKey?J.prototype[n]=function(r,o,a){return i(this,n,!0,"undirected"===(e.type||this.type),null,r,o,a,"update"===t)}:J.prototype[n]=function(r,o,a,s){return i(this,n,!1,"undirected"===(e.type||this.type),r,o,a,s,"update"===t)}})}),function(e){v.forEach(function(t){let{name:n,attacher:i}=t;i(e,n("Node"),0),i(e,n("Source"),1),i(e,n("Target"),2),i(e,n("Opposite"),3)})}(J),function(e){k.forEach(function(t){let{name:n,attacher:i}=t;i(e,n("Edge"),"mixed"),i(e,n("DirectedEdge"),"directed"),i(e,n("UndirectedEdge"),"undirected")})}(J),function(e){_.forEach(t=>{let{name:n,type:i,direction:r}=t;e.prototype[n]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return[];if(!arguments.length)return function(e,t){let n,i;if(0===e.size)return[];if("mixed"===t||t===e.type)return Array.from(e._edges.keys());let r=Array("undirected"===t?e.undirectedSize:e.directedSize),o="undirected"===t,a=e._edges.values(),s=0;for(;!0!==(n=a.next()).done;)(i=n.value).undirected===o&&(r[s++]=i.key);return r}(this,i);if(1==arguments.length){e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new p("Graph.".concat(n,': could not find the "').concat(e,'" node in the graph.'));return function(e,t,n,i){let r=[];return U(!1,e,t,n,i,function(e){r.push(e)}),r}(this.multi,"mixed"===i?this.type:i,r,t)}if(2==arguments.length){e=""+e,t=""+t;let a=this._nodes.get(e);if(!a)throw new p("Graph.".concat(n,':  could not find the "').concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new p("Graph.".concat(n,':  could not find the "').concat(t,'" target node in the graph.'));var o=this.multi;let s=[];return j(!1,i,o,r,a,t,function(e){s.push(e)}),s}throw new l("Graph.".concat(n,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))},function(e,t){let{name:n,type:i,direction:r}=t,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t,n){if("mixed"===i||"mixed"===this.type||i===this.type){if(1==arguments.length)return D(!1,this,i,n=e);if(2==arguments.length){e=""+e,n=t;let a=this._nodes.get(e);if(void 0===a)throw new p("Graph.".concat(o,': could not find the "').concat(e,'" node in the graph.'));return U(!1,this.multi,"mixed"===i?this.type:i,r,a,n)}if(3==arguments.length){e=""+e,t=""+t;let a=this._nodes.get(e);if(!a)throw new p("Graph.".concat(o,':  could not find the "').concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new p("Graph.".concat(o,':  could not find the "').concat(t,'" target node in the graph.'));return j(!1,i,this.multi,r,a,t,n)}throw new l("Graph.".concat(o,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};let a="map"+n[0].toUpperCase()+n.slice(1);e.prototype[a]=function(){let e,t=Array.prototype.slice.call(arguments),n=t.pop();if(0===t.length){let r=0;"directed"!==i&&(r+=this.undirectedSize),"undirected"!==i&&(r+=this.directedSize),e=Array(r);let o=0;t.push((t,i,r,a,s,d,c)=>{e[o++]=n(t,i,r,a,s,d,c)})}else e=[],t.push((t,i,r,o,a,s,d)=>{e.push(n(t,i,r,o,a,s,d))});return this[o].apply(this,t),e};let s="filter"+n[0].toUpperCase()+n.slice(1);e.prototype[s]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop(),n=[];return e.push((e,i,r,o,a,s,d)=>{t(e,i,r,o,a,s,d)&&n.push(e)}),this[o].apply(this,e),n};let d="reduce"+n[0].toUpperCase()+n.slice(1);e.prototype[d]=function(){let e,t,n=Array.prototype.slice.call(arguments);if(n.length<2||n.length>4)throw new l("Graph.".concat(d,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(n.length,")."));if("function"==typeof n[n.length-1]&&"function"!=typeof n[n.length-2])throw new l("Graph.".concat(d,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));2===n.length?(e=n[0],t=n[1],n=[]):3===n.length?(e=n[1],t=n[2],n=[n[0]]):4===n.length&&(e=n[2],t=n[3],n=[n[0],n[1]]);let i=t;return n.push((t,n,r,o,a,s,d)=>{i=e(i,t,n,r,o,a,s,d)}),this[o].apply(this,n),i}}(e,t);let{name:o,type:a,direction:s}=t,d="find"+o[0].toUpperCase()+o.slice(1,-1);e.prototype[d]=function(e,t,n){if("mixed"!==a&&"mixed"!==this.type&&a!==this.type)return!1;if(1==arguments.length)return D(!0,this,a,n=e);if(2==arguments.length){e=""+e,n=t;let i=this._nodes.get(e);if(void 0===i)throw new p("Graph.".concat(d,': could not find the "').concat(e,'" node in the graph.'));return U(!0,this.multi,"mixed"===a?this.type:a,s,i,n)}if(3==arguments.length){e=""+e,t=""+t;let i=this._nodes.get(e);if(!i)throw new p("Graph.".concat(d,':  could not find the "').concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new p("Graph.".concat(d,':  could not find the "').concat(t,'" target node in the graph.'));return j(!0,a,this.multi,s,i,t,n)}throw new l("Graph.".concat(d,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};let h="some"+o[0].toUpperCase()+o.slice(1,-1);e.prototype[h]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,n,i,r,o,a,s)=>t(e,n,i,r,o,a,s)),!!this[d].apply(this,e)};let f="every"+o[0].toUpperCase()+o.slice(1,-1);e.prototype[f]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,n,i,r,o,a,s)=>!t(e,n,i,r,o,a,s)),!this[d].apply(this,e)};let{name:g,type:y,direction:w}=t,m=g.slice(0,-1)+"Entries";e.prototype[m]=function(e,t){var n;if("mixed"!==y&&"mixed"!==this.type&&y!==this.type)return u();if(!arguments.length)return function(e,t){if(0===e.size)return u();let n="mixed"!==t&&t!==e.type,i="undirected"===t,r=e._edges.values();return{[Symbol.iterator](){return this},next(){let e,t;for(;;){if((e=r.next()).done)return e;if(t=e.value,!n||t.undirected===i)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}}}}(this,y);if(1==arguments.length){let t;e=""+e;let n=this._nodes.get(e);if(!n)throw new p("Graph.".concat(m,': could not find the "').concat(e,'" node in the graph.'));return t=u(),"undirected"!==y&&("out"!==w&&void 0!==n.in&&(t=c(t,E(n.in))),"in"!==w&&void 0!==n.out&&(t=c(t,E(n.out,w?void 0:n.key)))),"directed"!==y&&void 0!==n.undirected&&(t=c(t,E(n.undirected))),t}if(2==arguments.length){let i;e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new p("Graph.".concat(m,':  could not find the "').concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new p("Graph.".concat(m,':  could not find the "').concat(t,'" target node in the graph.'));return n=t,i=u(),"undirected"!==y&&(void 0!==r.in&&"out"!==w&&n in r.in&&(i=c(i,S(r.in,n))),void 0!==r.out&&"in"!==w&&n in r.out&&(w||r.key!==n)&&(i=c(i,S(r.out,n)))),"directed"!==y&&void 0!==r.undirected&&n in r.undirected&&(i=c(i,S(r.undirected,n))),i}throw new l("Graph.".concat(m,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}})}(J),function(e){N.forEach(t=>{let{name:n,type:i,direction:r}=t;e.prototype[n]=function(e){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return[];e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new p("Graph.".concat(n,': could not find the "').concat(e,'" node in the graph.'));var o="mixed"===i?this.type:i;if("mixed"!==o){if("undirected"===o)return Object.keys(t.undirected);if("string"==typeof r)return Object.keys(t[r])}let a=[];return M(!1,o,r,t,function(e){a.push(e)}),a},function(e,t){let{name:n,type:i,direction:r}=t,o="forEach"+n[0].toUpperCase()+n.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return;e=""+e;let n=this._nodes.get(e);if(void 0===n)throw new p("Graph.".concat(o,': could not find the "').concat(e,'" node in the graph.'));M(!1,"mixed"===i?this.type:i,r,n,t)};let a="map"+n[0].toUpperCase()+n.slice(1);e.prototype[a]=function(e,t){let n=[];return this[o](e,(e,i)=>{n.push(t(e,i))}),n};let s="filter"+n[0].toUpperCase()+n.slice(1);e.prototype[s]=function(e,t){let n=[];return this[o](e,(e,i)=>{t(e,i)&&n.push(e)}),n};let d="reduce"+n[0].toUpperCase()+n.slice(1);e.prototype[d]=function(e,t,n){if(arguments.length<3)throw new l("Graph.".concat(d,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));let i=n;return this[o](e,(e,n)=>{i=t(i,e,n)}),i}}(e,t);let{name:o,type:a,direction:s}=t,d=o[0].toUpperCase()+o.slice(1,-1),h="find"+d;e.prototype[h]=function(e,t){if("mixed"!==a&&"mixed"!==this.type&&a!==this.type)return;e=""+e;let n=this._nodes.get(e);if(void 0===n)throw new p("Graph.".concat(h,': could not find the "').concat(e,'" node in the graph.'));return M(!0,"mixed"===a?this.type:a,s,n,t)},e.prototype["some"+d]=function(e,t){return!!this[h](e,t)},e.prototype["every"+d]=function(e,t){return!this[h](e,(e,n)=>!t(e,n))};let{name:f,type:g,direction:y}=t,w=f.slice(0,-1)+"Entries";e.prototype[w]=function(e){if("mixed"!==g&&"mixed"!==this.type&&g!==this.type)return u();e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new p("Graph.".concat(w,': could not find the "').concat(e,'" node in the graph.'));var n="mixed"===g?this.type:g;if("mixed"!==n){if("undirected"===n)return P(null,t,t.undirected);if("string"==typeof y)return P(null,t,t[y])}let i=u(),r=new C;return"undirected"!==n&&("out"!==y&&(i=c(i,P(r,t,t.in))),"in"!==y&&(i=c(i,P(r,t,t.out)))),"directed"!==n&&(i=c(i,P(r,t,t.undirected))),i}})}(J);class X extends J{constructor(e){let t=n({type:"directed"},e);if("multi"in t&&!1!==t.multi)throw new l("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==t.type)throw new l('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class q extends J{constructor(e){let t=n({type:"undirected"},e);if("multi"in t&&!1!==t.multi)throw new l("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==t.type)throw new l('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class H extends J{constructor(e){let t=n({multi:!0},e);if("multi"in t&&!0!==t.multi)throw new l("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class Q extends J{constructor(e){let t=n({type:"directed",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new l("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==t.type)throw new l('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class V extends J{constructor(e){let t=n({type:"undirected",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new l("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==t.type)throw new l('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function Z(e){e.from=function(t,i){let r=new e(n({},t.options,i));return r.import(t),r}}Z(J),Z(X),Z(q),Z(H),Z(Q),Z(V),J.Graph=J,J.DirectedGraph=X,J.UndirectedGraph=q,J.MultiGraph=H,J.MultiDirectedGraph=Q,J.MultiUndirectedGraph=V,J.InvalidArgumentsGraphError=l,J.NotFoundGraphError=p,J.UsageGraphError=f,e.s(["palette",()=>$],86282);let $={light:{background:"#f0f4f8",foreground:"#0a1829",primary:"#1e3a5f",secondary:"#2d5a5a",accent:"#ec4899",destructive:"#dc2626",success:"#059669",warning:"#d97706",info:"#0284c7"},dark:{background:"#0a1829",foreground:"#e0f2fe",primary:"#4a90e2",secondary:"#1e3a5f",accent:"#f472b6",destructive:"#ef4444",success:"#10b981",warning:"#f59e0b",info:"#06b6d4"}}}]);